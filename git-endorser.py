import argparse
from dataclasses import dataclass
from typing import Optional, Self, Union
from datetime import datetime, timedelta


@dataclass
class CandidateInfo:
    # Shorthand -- unique ID for each candidate
    id: str
    join: datetime
    end: datetime
    endorsement: list[tuple[Self, datetime]]


@dataclass
class Candidate:
    name: str
    candidate: Optional[CandidateInfo] = None


@dataclass
class AddCandidate:
    name: str
    date: datetime


@dataclass
class DropCandidate:
    name: str
    date: datetime


@dataclass
class EndorseCandidate:
    name: str
    endorsee: str
    date: datetime


Action = Union[AddCandidate, DropCandidate, EndorseCandidate]


def group(l: list, n: int = 2) -> list[list]:
    return [l[i : i + n] for i in range(0, len(l), n)]


def read_date(time: str) -> datetime:
    return datetime.strptime(time, "%m/%d/%Y")


def write_date(time: datetime):
    return datetime.strftime(time, "%Y-%m-%d")


class GitWrapper:
    def __init__(self):
        self.actions = []

    def add_action(self, action: Action):
        self.actions.append(action)

    def process_actions(self) -> list[str]:
        ret = []
        ret.append("git checkout --orphan race")

        race_begin_time = min(map(lambda x: x.date, self.actions)) - timedelta(days=1)
        ret.append(
            f"GIT_COMMITTER_DATE='{(d:=write_date(race_begin_time))} 00:00:00 +1000' git commit --date='{d}' --allow-empty -m 'we start the race'"
        )

        self.actions.sort(key=lambda x: (x.date, x.name))

        for action in self.actions:
            match action:
                case AddCandidate():
                    ret.append(f"git checkout --orphan {action.name}")
                    ret.append(
                        f"GIT_COMMITTER_DATE='{(d:=write_date(action.date))} 00:00:00 +1000' git commit --allow-empty --date='{d}' -m '{action.name} has joined'"
                    )
                case DropCandidate():
                    ret.append(f"git checkout {action.name}")
                    ret.append(
                        f"GIT_COMMITTER_DATE='{(d:=write_date(action.date))} 00:00:00 +1000' git commit --allow-empty --date='{d}' -m '{action.name} has dropped'"
                    )
                case EndorseCandidate():
                    ret.append(f"git checkout {action.endorsee}")
                    ret.append(
                        f"git merge --allow-unrelated-histories -m '{action.name} has endorsed {action.endorsee}' {action.name}"
                    )
                    ret.append(
                        f"GIT_COMMITTER_DATE='{(d:=write_date(action.date))} 00:00:00 +1000' git commit --amend --date='{d}' --no-edit"
                    )

        race_end_time = max(map(lambda x: x.date, self.actions)) + timedelta(days=1)
        ret.append(f"git checkout race")
        ret.append(
            f"GIT_COMMITTER_DATE='{(d:=write_date(race_end_time))} 00:00:00 +1000' git commit --date='{d}' --allow-empty -m 'the race ends'"
        )

        return ret


def get_actions(candidate_id_map: dict[str, Candidate]):
    adds = [
        AddCandidate(val.candidate.id, val.candidate.join)
        for _, val in candidate_id_map.items()
        if val.candidate is not None
    ]
    drops = [
        DropCandidate(val.candidate.id, val.candidate.end)
        for _, val in candidate_id_map.items()
        if val.candidate is not None
    ]
    endorses = [
        EndorseCandidate(val.candidate.id, c.candidate.id, d)
        for _, val in candidate_id_map.items()
        if val.candidate is not None
        for (c, d) in val.candidate.endorsement
    ]

    actions = [*adds, *drops, *endorses]
    return actions


def process_lines(lines: list[list[str]]) -> dict[str, Candidate]:
    candidate_mapping = {}
    for line in lines:
        # Check if this is a name -> id mapping
        if len(line) == 2:
            full_name, c_id = line
            candidate_mapping[c_id] = Candidate(full_name)
            continue

        # This is an id -> candidate information mapping
        name, join, end, *rest = line

        wrapper = candidate_mapping[name]
        wrapper.candidate = CandidateInfo(
            name,
            read_date(join),
            read_date(end),
            [(candidate_mapping[name], read_date(date)) for name, date in group(rest)],
        )

    return candidate_mapping


def read_candidates_from_file(file_name: str) -> dict[str, CandidateInfo]:
    with open(file_name) as f:
        lines = [
            line.strip().split(",")
            for line in f.readlines()
            if len(line) > 0 and not line.strip().startswith("//")
        ]
        return process_lines(lines)


def main():
    parser = argparse.ArgumentParser(
        prog="git-endorser",
        description="Make git commands to create a network graph composed of commits and merges from presidential primaries' entrances to the race",
    )
    parser.add_argument(
        "--filename", default="data/dem-primary-2020.csvish", required=False
    )
    args = parser.parse_args()

    FILENAME = args.filename

    gw = GitWrapper()
    candidate_mapping = read_candidates_from_file(FILENAME)
    actions = get_actions(candidate_mapping)
    [gw.add_action(action) for action in actions]

    print("\n".join(gw.process_actions()))


if __name__ == "__main__":
    main()
