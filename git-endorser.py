import os
from git import Repo
import argparse
from dataclasses import dataclass
from typing import Any, Optional, Self, Union
from datetime import datetime, timedelta
import pytz


@dataclass
class CandidateInfo:
    # Shorthand -- unique ID for each candidate
    id: str
    join: datetime
    end: datetime
    endorsement: list[tuple[Self, datetime]]


@dataclass
class Candidate:
    name: str
    candidate: Optional[CandidateInfo] = None


@dataclass
class AddCandidate:
    name: str
    date: datetime


@dataclass
class DropCandidate:
    name: str
    date: datetime


@dataclass
class EndorseCandidate:
    name: str
    endorsee: str
    date: datetime


Action = Union[AddCandidate, DropCandidate, EndorseCandidate]


def group(big_list: list[Any], n: int = 2) -> list[list]:
    return [big_list[i : i + n] for i in range(0, len(big_list), n)]


def read_date(time: str) -> datetime:
    return pytz.utc.localize(datetime.strptime(time, "%m/%d/%Y"))


def write_date(time: datetime):
    return datetime.strftime(time, "%Y-%m-%d")


class GitWrapper:
    def __init__(self, path: str):
        self.repo = Repo.init(path, mkdir=True)

    def commit(self, msg: str, date: datetime) -> str:
        self.repo.index.commit(msg, commit_date=date, author_date=date)

    def process_actions(self, actions: list[Action]):
        race_begin_time = min(map(lambda x: x.date, actions)) - timedelta(days=1)
        repo = self.repo

        repo.git.checkout("--orphan", "race")
        self.commit("the race begins", race_begin_time)

        actions.sort(key=lambda x: (x.date, x.name))

        for action in actions:
            match action:
                case AddCandidate():
                    repo.git.checkout("--orphan", action.name)
                    self.commit(f"{action.name} has joined", action.date)
                case DropCandidate():
                    repo.git.checkout(action.name)
                    self.commit(
                        f"{action.name} has dropped",
                        action.date,
                    )
                case EndorseCandidate():
                    try:
                        repo.git.checkout(action.endorsee)
                        repo.git.merge(
                            "--allow-unrelated-histories",
                            "-m",
                            f"{action.name} has backed {action.endorsee}",
                            action.name,
                        )
                    except Exception:
                        print(action)
                        raise Exception()
                    os.environ["GIT_COMMITTER_DATE"] = str(action.date)
                    os.environ["GIT_AUTHOR_DATE"] = str(action.date)

                    repo.git.commit(
                        "--amend", f"--date={action.date}", "--allow-empty", "--no-edit"
                    )

        race_end_time = max(map(lambda x: x.date, actions)) + timedelta(days=1)
        repo.git.checkout("race")
        self.commit("the race has ended", race_end_time)


def get_actions(candidate_id_map: dict[str, Candidate]) -> list[Action]:
    adds = [
        AddCandidate(val.candidate.id, val.candidate.join)
        for _, val in candidate_id_map.items()
        if val.candidate is not None
    ]
    drops = [
        DropCandidate(val.candidate.id, val.candidate.end)
        for _, val in candidate_id_map.items()
        if val.candidate is not None
    ]
    endorses = [
        EndorseCandidate(val.candidate.id, c.candidate.id, d)
        for _, val in candidate_id_map.items()
        if val.candidate is not None
        for (c, d) in val.candidate.endorsement
    ]

    actions = [*adds, *drops, *endorses]
    return actions


def process_lines(lines: list[list[str]]) -> dict[str, Candidate]:
    candidate_mapping = {}
    for line in lines:
        # Check if this is a name -> id mapping
        if len(line) == 2:
            full_name, c_id = line
            candidate_mapping[c_id] = Candidate(full_name)
            continue

        # This is an id -> candidate information mapping
        name, join, end, *rest = line

        wrapper = candidate_mapping[name]
        wrapper.candidate = CandidateInfo(
            name,
            read_date(join),
            read_date(end),
            [(candidate_mapping[name], read_date(date)) for name, date in group(rest)],
        )

    return candidate_mapping


def read_candidates_from_file(file_name: str) -> dict[str, Candidate]:
    with open(file_name) as f:
        lines = [
            line.strip().split(",")
            for line in f.readlines()
            if len(line) > 0 and not line.strip().startswith("//")
        ]
        return process_lines(lines)


def main():
    parser = argparse.ArgumentParser(
        prog="git-endorser",
        description="Make git commands to create a network graph composed of commits and merges from presidential primaries' entrances to the race",
    )
    parser.add_argument(
        "--filename", default="data/dem-primary-2020.csvish", required=False
    )
    parser.add_argument("--output", default="dem2020", required=False)
    args = parser.parse_args()

    FILENAME = args.filename

    gw = GitWrapper(args.output)
    candidate_mapping = read_candidates_from_file(FILENAME)
    actions = get_actions(candidate_mapping)
    gw.process_actions(actions)


if __name__ == "__main__":
    main()
